name: 'Upstream Dependency Checker'
description: 'Checks for updates in upstream repositories. Optionally tracks state via auto-merged PR.'

inputs:
  repositories:
    description: |
      JSON array of repository objects.
      Example: [{"repo": "owner/repo", "check_type": "release"}]
      check_type options: release | prerelease | commit | auto (default: auto)
    required: true
  state_file:
    description: |
      Path to state file for version tracking.
      Empty = query-only mode (no commits, has_updates always false)
    required: false
    default: ''
  token:
    description: |
      GitHub token (PAT with repo scope) for API access and PR creation.
      Required for: private repos, creating PRs, avoiding rate limits.
    required: false
    default: ''
  pr_labels:
    description: 'Comma-separated labels for the PR (useful for release-drafter categorization)'
    required: false
    default: 'dependencies'
  auto_merge:
    description: 'Automatically merge the PR after creation'
    required: false
    default: 'true'

outputs:
  results:
    description: |
      JSON array of results.
      Example: [{"repo": "owner/repo", "sha": "abc123...", "tag": "v1.0.0", "check_type": "release", "is_updated": true}]
    value: ${{ steps.check.outputs.results }}
  has_updates:
    description: |
      True only when: state_file was provided AND file existed AND content changed
    value: ${{ steps.check.outputs.has_updates }}
  pr_number:
    description: 'PR number if created'
    value: ${{ steps.pr.outputs.pr_number }}
  pr_url:
    description: 'PR URL if created'
    value: ${{ steps.pr.outputs.pr_url }}

runs:
  using: "composite"
  env:
    GH_TOKEN: ${{ inputs.token || github.token }}  # Also used for GitHub CLI
    STATE_FILE: ${{ inputs.state_file }}
  steps:
    - name: 'Check upstream repositories'
      id: check
      shell: bash
      env:
        REPOSITORIES: ${{ inputs.repositories }}
      run: |
        set -euo pipefail
        
        #â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Helper Functions
        #â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        api_get() {
          local url="$1"
          local args=(-s -L -H "Accept: application/vnd.github.v3+json")
          [[ -n "${GH_TOKEN:-}" ]] && args+=(-H "Authorization: Bearer $GH_TOKEN")
          curl "${args[@]}" "$url"
        }
        
        get_release_tag() {
          api_get "https://api.github.com/repos/$1/releases/latest" | jq -r '.tag_name // empty'
        }
        
        get_prerelease_tag() {
          api_get "https://api.github.com/repos/$1/releases?per_page=1" | jq -r '.[0].tag_name // empty'
        }
        
        get_latest_commit() {
          api_get "https://api.github.com/repos/$1/commits?per_page=1" | jq -r '.[0].sha // empty'
        }
        
        resolve_tag_to_sha() {
          local repo="$1" tag="$2"
          local ref_data sha obj_type
          
          ref_data=$(api_get "https://api.github.com/repos/$repo/git/refs/tags/$tag")
          sha=$(echo "$ref_data" | jq -r '.object.sha // empty')
          obj_type=$(echo "$ref_data" | jq -r '.object.type // empty')
          
          # Dereference annotated tag
          if [[ "$obj_type" == "tag" ]]; then
            sha=$(api_get "https://api.github.com/repos/$repo/git/tags/$sha" | jq -r '.object.sha // empty')
          fi
          echo "$sha"
        }
        
        #â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Input Validation
        #â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        if ! echo "$REPOSITORIES" | jq empty 2>/dev/null; then
          echo "::error::Invalid JSON in repositories input"
          echo "::example::[{"\"repo\"": "\"owner/repo\"", "\"check_type\"": "\"release\""}]"
          exit 1
        fi
        
        #â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Load Current State
        #â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        declare -A current_state  # Format: current_state[repo]="sha|tag|check_type"
        state_file_existed=false
        
        if [[ -n "$STATE_FILE" && -f "$STATE_FILE" ]]; then
          state_file_existed=true
          echo "ğŸ“– Loading state from: $STATE_FILE"
          while IFS=' ' read -r repo sha tag check_type; do
            [[ -z "$repo" || "$repo" =~ ^# ]] && continue
            current_state["$repo"]="${sha}|${tag:--}|${check_type:-auto}"
          done < "$STATE_FILE"
        elif [[ -n "$STATE_FILE" ]]; then
          echo "ğŸ“ State file not found, will initialize: $STATE_FILE"
        else
          echo "â„¹ï¸  Query-only mode (no state_file specified)"
        fi
        
        #â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Check Each Repository
        #â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "ğŸ” Checking upstream repositories"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        
        declare -A new_state
        results_json="[]"
        has_updates=false
        update_summary=""
        
        while read -r entry; do
          repo=$(echo "$entry" | jq -r '.repo // empty')
          check_type=$(echo "$entry" | jq -r '.check_type // "auto"')
          
          [[ -z "$repo" ]] && continue
          echo ""
          echo "ğŸ“¦ $repo (mode: $check_type)"
          
          tag="" sha="" actual_type=""
          
          # Determine version based on check_type
          case "$check_type" in
            release)
              tag=$(get_release_tag "$repo")
              [[ -z "$tag" ]] && { echo "   âš ï¸ No stable release found"; continue; }
              actual_type="release"
              ;;
            prerelease)
              tag=$(get_prerelease_tag "$repo")
              [[ -z "$tag" ]] && { echo "   âš ï¸ No releases found"; continue; }
              actual_type="prerelease"
              ;;
            commit)
              sha=$(get_latest_commit "$repo")
              [[ -z "$sha" ]] && { echo "   âš ï¸ Could not fetch commits"; continue; }
              tag="-"
              actual_type="commit"
              ;;
            auto)
              if tag=$(get_release_tag "$repo") && [[ -n "$tag" ]]; then
                actual_type="release"
              elif tag=$(get_prerelease_tag "$repo") && [[ -n "$tag" ]]; then
                actual_type="prerelease"
              elif sha=$(get_latest_commit "$repo") && [[ -n "$sha" ]]; then
                tag="-"
                actual_type="commit"
              else
                echo "   âš ï¸ Could not fetch any version"
                continue
              fi
              ;;
            *)
              echo "   âš ï¸ Invalid check_type: $check_type"
              continue
              ;;
          esac
          
          # Resolve tag to SHA if needed
          if [[ "$actual_type" != "commit" && -n "$tag" ]]; then
            sha=$(resolve_tag_to_sha "$repo" "$tag")
            [[ -z "$sha" ]] && { echo "   âš ï¸ Could not resolve tag to SHA"; continue; }
          fi
          
          echo "   âœ“ ${tag:--} (${sha:0:7}) [$actual_type]"
          
          # Store new state
          new_state["$repo"]="${sha}|${tag}|${actual_type}"
          
          # Check for updates (only if state_file existed)
          is_updated=false
          if [[ -n "${current_state[$repo]:-}" ]]; then
            IFS='|' read -r old_sha old_tag old_type <<< "${current_state[$repo]}"
            if [[ "$sha" != "$old_sha" ]]; then
              is_updated=true
              if $state_file_existed; then
                has_updates=true
                if [[ "$tag" != "-" && "$old_tag" != "-" ]]; then
                  update_summary+="- **$repo**: \`$old_tag\` â†’ \`$tag\`\n"
                else
                  update_summary+="- **$repo**: \`${old_sha:0:7}\` â†’ \`${sha:0:7}\`\n"
                fi
                echo "   âœ… UPDATE DETECTED"
              fi
            fi
          elif $state_file_existed; then
            # New repo added (only log if state file existed before)
            is_updated=true
            has_updates=true
            update_summary+="- **$repo**: Added at \`${tag:--}\` [$actual_type]\n"
            echo "   â„¹ï¸ New repository added"
          fi
          
          # Build results JSON
          results_json=$(echo "$results_json" | jq \
            --arg repo "$repo" \
            --arg sha "$sha" \
            --arg tag "$tag" \
            --arg type "$actual_type" \
            --argjson updated "$is_updated" \
            '. + [{"repo": $repo, "sha": $sha, "tag": $tag, "check_type": $type, "is_updated": $updated}]')
          
        done < <(echo "$REPOSITORIES" | jq -c '.[]')
        
        #â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Write State File (if specified)
        #â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        if [[ -n "$STATE_FILE" && ${#new_state[@]} -gt 0 ]]; then
          mkdir -p "$(dirname "$STATE_FILE")"
          {
            echo "# Upstream dependency versions"
            echo "# Format: owner/repo sha tag check_type"
            echo "# Updated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
            echo ""
            for repo in $(printf '%s\n' "${!new_state[@]}" | sort); do
              IFS='|' read -r sha tag type <<< "${new_state[$repo]}"
              echo "$repo $sha $tag $type"
            done
          } > "$STATE_FILE"
          echo ""
          echo "ğŸ“ State written to: $STATE_FILE"
        fi
        
        #â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Output Summary
        #â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "ğŸ“Š Summary"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "$results_json" | jq -r '.[] | "  \(.repo): \(.tag) [\(.check_type)]\(if .is_updated then " âœ…" else "" end)"'
        echo ""
        echo "has_updates: $has_updates"
        
        # Set outputs
        {
          echo "results<<EOF"
          echo "$results_json"
          echo "EOF"
          echo "has_updates=$has_updates"
          echo "update_summary<<EOF"
          echo -e "$update_summary"
          echo "EOF"
        } >> "$GITHUB_OUTPUT"

    - name: 'Create and merge PR'
      id: pr
      if: steps.check.outputs.has_updates == 'true' && inputs.state_file != ''
      shell: bash
      env:
        PR_LABELS: ${{ inputs.pr_labels }}
        AUTO_MERGE: ${{ inputs.auto_merge }}
        UPDATE_SUMMARY: ${{ steps.check.outputs.update_summary }}
      run: |
        set -euo pipefail
        
        #â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Commit and Push
        #â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        # Generate unique branch name
        BRANCH="deps/upstream-$(date +%Y%m%d-%H%M%S)-$RANDOM"
        BASE_BRANCH="${GITHUB_REF#refs/heads/}"
        
        echo "ğŸ”€ Creating branch: $BRANCH"
        
        # Configure git
        git config user.name "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
        
        # Create and switch to new branch
        git checkout -b "$BRANCH"
        
        # Commit changes
        git add "$STATE_FILE"
        
        PR_TITLE="chore(deps): update upstream dependencies"
        PR_BODY="## Updated Dependencies
        
        ${UPDATE_SUMMARY}
        
        ---
        *Auto-generated by [upstream-checker](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"
        
        git commit -m "$PR_TITLE" -m "$PR_BODY"
        
        # Push branch
        echo "ğŸ“¤ Pushing branch..."
        git push origin "$BRANCH"
        
        #â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # Create PR and Merge
        #â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        # Create PR with labels
        echo "ğŸ“‹ Creating PR..."
        IFS=',' read -ra LABEL_ARRAY <<< "$PR_LABELS"
        LABEL_ARGS=""
        for label in "${LABEL_ARRAY[@]}"; do
          label=$(echo "$label" | xargs)  # trim whitespace
          [[ -n "$label" ]] && LABEL_ARGS+="--label \"$label\" "
        done
        
        PR_URL=$(eval gh pr create \
          --title "\"$PR_TITLE\"" \
          --body "\"$PR_BODY\"" \
          --base "$BASE_BRANCH" \
          --head "$BRANCH" \
          $LABEL_ARGS)
        
        PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
        
        echo "âœ… Created PR #$PR_NUMBER: $PR_URL"
        
        # Auto-merge if enabled
        if [[ "$AUTO_MERGE" == "true" ]]; then
          echo "ğŸ”„ Merging PR..."
          gh pr merge "$PR_NUMBER" --merge --delete-branch
          echo "âœ… PR merged and branch deleted"
        fi
        
        # Set outputs
        {
          echo "pr_number=$PR_NUMBER"
          echo "pr_url=$PR_URL"
        } >> "$GITHUB_OUTPUT"




